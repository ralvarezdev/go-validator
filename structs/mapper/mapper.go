package mapper

import (
	"fmt"
	"reflect"
	"strings"
)

// Protobuf fields generated by the protoc compiler
const (
	State              = "state"
	SizeCache          = "sizeCache"
	UnknownFields      = "unknownFields"
	ProtobufTag        = "protobuf"
	ProtobufOneOf      = "oneof"
	ProtobufNamePrefix = "name="
	JSONTag            = "json"
	JSONOmitempty      = "omitempty"
)

type (
	// Mapper is a map of fields to validate from a struct
	Mapper struct {
		// fields key is the field name and value is the name used in the validation error
		fields *map[string]string

		// parsedFields key is the field name and value is a boolean to determine if the field was parsed
		parsedFields *map[string]bool

		// nestedMappers key is the field name of the nested struct and value is the nested mapper
		nestedMappers *map[string]*Mapper
	}

	// Generator is an interface for creating a mapper
	Generator interface {
		NewMapper(structInstance interface{}) (*Mapper, error)
	}

	// ProtobufGenerator is a generator for Protobuf mappers
	ProtobufGenerator struct {
		logger *Logger
	}

	// JSONGenerator is a generator for JSON mappers
	JSONGenerator struct {
		logger *Logger
	}
)

// NewMapper creates a new mapper
func NewMapper() *Mapper {
	return &Mapper{}
}

// GetFieldsValidationsName returns the fields of the mapper
func (m *Mapper) GetFieldsValidationsName() *map[string]string {
	return m.fields
}

// GetFieldValidationName returns the validation name of a field
func (m *Mapper) GetFieldValidationName(fieldName string) (string, bool) {
	// Check if the fields map is nil
	if m.fields == nil {
		return "", false
	}
	return (*m.fields)[fieldName], true
}

// AddFieldValidationName adds a field validation name to the mapper
func (m *Mapper) AddFieldValidationName(fieldName, fieldTagName string) {
	// Initialize the fields map if it is nil
	if m.fields == nil {
		m.fields = &map[string]string{}
	}

	// Add the field validation name to the map
	(*m.fields)[fieldName] = fieldTagName
}

// HasFieldsValidations returns if the mapper has fields
func (m *Mapper) HasFieldsValidations() bool {
	return m.fields != nil
}

// GetParsedFields returns the parsed fields of the mapper
func (m *Mapper) GetParsedFields() *map[string]bool {
	return m.parsedFields
}

// IsFieldParsed returns if a field was parsed
func (m *Mapper) IsFieldParsed(fieldName string) (bool, bool) {
	// Check if the parsed fields map is nil
	if m.parsedFields == nil {
		return false, false
	}
	return (*m.parsedFields)[fieldName], true
}

// SetFieldParsed sets if a field was parsed
func (m *Mapper) SetFieldParsed(fieldName string, parsed bool) {
	// Initialize the parsed fields map if it is nil
	if m.parsedFields == nil {
		m.parsedFields = &map[string]bool{}
	}

	// Set if the field was parsed
	(*m.parsedFields)[fieldName] = parsed
}

// GetNestedMappers returns the nested mappers of the mapper
func (m *Mapper) GetNestedMappers() *map[string]*Mapper {
	return m.nestedMappers
}

// GetFieldNestedMapper returns the nested mapper of a field
func (m *Mapper) GetFieldNestedMapper(fieldName string) *Mapper {
	// Check if the nested mappers map is nil
	if m.nestedMappers == nil {
		return nil
	}

	return (*m.nestedMappers)[fieldName]
}

// AddFieldNestedMapper adds a nested mapper to the mapper
func (m *Mapper) AddFieldNestedMapper(fieldName string, nestedMapper *Mapper) {
	// Initialize the nested mappers map if it is nil
	if m.nestedMappers == nil {
		m.nestedMappers = &map[string]*Mapper{}
	}

	// Add the nested mapper to the map
	(*m.nestedMappers)[fieldName] = nestedMapper
}

// NewProtobufGenerator creates a new Protobuf generator
func NewProtobufGenerator(logger *Logger) *ProtobufGenerator {
	return &ProtobufGenerator{
		logger: logger,
	}
}

// NewJSONGenerator creates a new JSON generator
func NewJSONGenerator(logger *Logger) *JSONGenerator {
	return &JSONGenerator{
		logger: logger,
	}
}

// NewMapper creates the fields to validate from a Protobuf compiled struct
func (p *ProtobufGenerator) NewMapper(structInstance interface{}) (
	*Mapper,
	error,
) {
	// Reflection of data
	typeReflection := reflect.TypeOf(structInstance)

	// If data is a pointer, dereference it
	if typeReflection.Kind() == reflect.Ptr {
		typeReflection = typeReflection.Elem()
	}

	// Get the struct name
	structName := typeReflection.Name()

	// Initialize the root map of fields and the map of nested mappers
	rootMapper := NewMapper()

	// Reflection of the type of data
	for i := 0; i < typeReflection.NumField(); i++ {
		// Get the field type through reflection
		structField := typeReflection.Field(i)
		fieldType := structField.Type
		fieldName := structField.Name

		// Check if the field is a protoc generated field
		if fieldName == State || fieldName == SizeCache || fieldName == UnknownFields {
			continue
		}

		// Get the Protobuf tag of the field
		var protobufTag string
		if fieldType.Kind() != reflect.Ptr {
			// Get the Protobuf tag of the field
			protobufTag = structField.Tag.Get(ProtobufTag)
			if protobufTag == "" {
				return nil, fmt.Errorf(ErrMissingProtobufTag, fieldName)
			}
		} else {
			// Dereference the pointer
			fieldType = fieldType.Elem()

			// Get the Protobuf tag of the field
			protobufTag = structField.Tag.Get(ProtobufTag)
			if protobufTag == "" {
				return nil, fmt.Errorf(ErrMissingProtobufTag, fieldName)
			}

			// Check if the element type is not a struct and the tag to determine if it contains 'oneof', which means it is an optional struct field
			if fieldType.Kind() != reflect.Struct || strings.Contains(
				protobufTag,
				ProtobufOneOf,
			) {
				// Add the field to the parsed fields map
				rootMapper.SetFieldParsed(fieldName, true)

				// Print field
				if p.logger != nil {
					p.logger.DetectedField(
						structName,
						fieldName,
						fieldType,
						protobufTag,
						false,
						true,
					)
				}
				continue
			}

			// Create a new Mapper for the nested struct field
			fieldNestedMapper, err := p.NewMapper(
				reflect.New(fieldType).Interface(),
			)
			if err != nil {
				return nil, err
			}

			// Add the nested fields to the map
			rootMapper.AddFieldNestedMapper(fieldName, fieldNestedMapper)
		}

		// Get the field name from the Protobuf tag
		var protobufName string
		for _, part := range strings.Split(protobufTag, ",") {
			if strings.HasPrefix(part, ProtobufNamePrefix) {
				protobufName = strings.TrimPrefix(part, ProtobufNamePrefix)
				break
			}
		}

		// Check if the field name is empty
		if protobufName == "" {
			return nil, fmt.Errorf(ErrMissingProtobufTagName, fieldName)
		}

		// Add the field to the fields map
		rootMapper.AddFieldValidationName(fieldName, protobufName)

		// Add the field to the parsed fields map
		rootMapper.SetFieldParsed(fieldName, true)

		// Print field
		if p.logger != nil {
			p.logger.DetectedField(
				structName,
				fieldName,
				fieldType,
				protobufTag,
				true,
				true,
			)
		}
	}

	return rootMapper, nil
}

// NewMapper creates the fields to validate from a JSON struct
func (j *JSONGenerator) NewMapper(structInstance interface{}) (
	*Mapper,
	error,
) {
	// Reflection of data
	typeReflection := reflect.TypeOf(structInstance)

	// If data is a pointer, dereference it
	if typeReflection.Kind() == reflect.Ptr {
		typeReflection = typeReflection.Elem()
	}

	// Get the struct name
	structName := typeReflection.Name()

	// Initialize the root map of fields and the map of nested mappers
	rootMapper := NewMapper()

	// Reflection of the type of data
	var jsonTag string
	var jsonName string
	for i := 0; i < typeReflection.NumField(); i++ {
		// Get the field type through reflection
		structField := typeReflection.Field(i)
		fieldType := structField.Type
		fieldTag := structField.Tag
		fieldName := structField.Name

		// Get the JSON tag of the field
		jsonTag = fieldTag.Get(JSONTag)
		if jsonTag == "" {
			// Check if the field is a protoc generated field
			if fieldName == State || fieldName == SizeCache || fieldName == UnknownFields {
				return nil, fmt.Errorf(
					ErrMissingJSONTagLooksLikeProtocField,
					fieldName,
				)
			}
			return nil, fmt.Errorf(ErrMissingJSONTag, fieldName)
		}

		// Check if the JSON tag is unassigned or if it contains 'omitempty', which means it is an optional field
		if jsonTag == "-" || strings.Contains(jsonTag, JSONOmitempty) {
			// Add the field to the parsed fields map
			isParsed := jsonTag != "-"
			rootMapper.SetFieldParsed(fieldName, isParsed)

			// Print field
			if j.logger != nil {
				j.logger.DetectedField(
					structName,
					fieldName,
					fieldType,
					jsonTag,
					false,
					isParsed,
				)
			}
			continue
		}

		// Dereference the pointer
		if fieldType.Kind() == reflect.Ptr {
			fieldType = fieldType.Elem()
		}

		// Check if the element type is a struct
		if fieldType.Kind() == reflect.Struct {
			// Create a new Mapper for the nested struct field
			fieldNestedMapper, err := j.NewMapper(
				reflect.New(fieldType).Interface(),
			)
			if err != nil {
				return nil, err
			}

			// Add the nested fields to the map
			rootMapper.AddFieldNestedMapper(fieldName, fieldNestedMapper)
		}

		// Get the field name from the JSON tag
		tagParts := strings.Split(jsonTag, ",")
		if len(tagParts) == 0 {
			return nil, fmt.Errorf(ErrEmptyJSONTag, fieldName)
		}
		jsonName = tagParts[0]

		// Add the field to the fields map
		rootMapper.AddFieldValidationName(fieldName, jsonName)

		// Add the field to the parsed fields map
		rootMapper.SetFieldParsed(fieldName, true)

		// Print field
		if j.logger != nil {
			j.logger.DetectedField(
				structName,
				fieldName,
				fieldType,
				jsonTag,
				true,
				true,
			)
		}
	}

	return rootMapper, nil
}
