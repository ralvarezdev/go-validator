package mapper

import (
	"fmt"
	goflagsmode "github.com/ralvarezdev/go-flags/mode"
	"reflect"
	"strings"
)

// Protobuf fields generated by the protoc compiler
const (
	State              = "state"
	SizeCache          = "sizeCache"
	UnknownFields      = "unknownFields"
	ProtobufTag        = "protobuf"
	ProtobufOneOf      = "oneof"
	ProtobufNamePrefix = "name="
	JSONTag            = "json"
	JSONOmitempty      = "omitempty"
)

type (
	// Mapper is a map of fields to validate from a struct
	Mapper struct {
		Fields        map[string]string // Key is the field name and value is the name used in the validation error
		NestedMappers map[string]*Mapper
	}

	// Generator is an interface for creating a mapper
	Generator interface {
		NewMapper(structInstance interface{}) (*Mapper, error)
	}

	// ProtobufGenerator is a generator for Protobuf mappers
	ProtobufGenerator struct {
		mode *goflagsmode.Flag
	}

	// JSONGenerator is a generator for JSON mappers
	JSONGenerator struct {
		mode *goflagsmode.Flag
	}
)

// NewProtobufGenerator creates a new Protobuf generator
func NewProtobufGenerator(mode *goflagsmode.Flag) *ProtobufGenerator {
	return &ProtobufGenerator{
		mode: mode,
	}
}

// NewJSONGenerator creates a new JSON generator
func NewJSONGenerator(mode *goflagsmode.Flag) *JSONGenerator {
	return &JSONGenerator{
		mode: mode,
	}
}

// NewMapper creates the fields to validate from a Protobuf compiled struct
func (p *ProtobufGenerator) NewMapper(structInstance interface{}) (
	*Mapper,
	error,
) {
	// Reflection of data
	typeReflection := reflect.TypeOf(structInstance)

	// If data is a pointer, dereference it
	if typeReflection.Kind() == reflect.Ptr {
		typeReflection = typeReflection.Elem()
	}

	// Initialize the map fields and the map of nested mappers
	rootMapper := make(map[string]string)
	rootNestedMappers := make(map[string]*Mapper)

	// Reflection of the type of data
	var protobufTag string
	var protobufName string
	for i := 0; i < typeReflection.NumField(); i++ {
		// Get the field type through reflection
		field := typeReflection.Field(i)

		// Check if the field is a protoc generated field
		if field.Name == State || field.Name == SizeCache || field.Name == UnknownFields {
			continue
		}

		// Print field on debug mode
		fieldType := field.Type
		if p.mode != nil && p.mode.IsDebug() {
			fmt.Printf("field '%v' type: %v\n", field.Name, fieldType)
		}

		// Check if the field is a pointer
		if fieldType.Kind() != reflect.Ptr {
			// Get the Protobuf tag of the field
			protobufTag = field.Tag.Get(ProtobufTag)
			if protobufTag == "" {
				return nil, fmt.Errorf(MissingProtobufTagError, field.Name)
			}
		} else {
			fieldType = fieldType.Elem()

			// Check if the element type is not a struct, which would mean that it is an optional scalar type
			if fieldType.Kind() != reflect.Struct {
				continue
			}

			// Get the Protobuf tag of the field
			protobufTag = field.Tag.Get(ProtobufTag)
			if protobufTag == "" {
				return nil, fmt.Errorf(MissingProtobufTagError, field.Name)
			}

			// Check the tag to determine if it contains 'oneof', which means it is an optional struct field
			if ok := strings.Contains(protobufTag, ProtobufOneOf); ok {
				continue
			}

			// Create a new Mapper for the nested struct field
			fieldNestedMapper, err := p.NewMapper(
				reflect.New(fieldType).Interface(),
			)
			if err != nil {
				return nil, err
			}

			// Add the nested fields to the map
			rootNestedMappers[field.Name] = fieldNestedMapper
		}

		// Get the field name from the Protobuf tag
		tagParts := strings.Split(protobufTag, ",")
		protobufName = ""
		for _, part := range tagParts {
			if strings.HasPrefix(part, ProtobufNamePrefix) {
				protobufName = strings.TrimPrefix(part, ProtobufNamePrefix)
				break
			}
		}

		// Check if the field name is empty
		if protobufName == "" {
			return nil, fmt.Errorf(MissingProtobufTagNameError, field.Name)
		}

		// Check if the field name has already been assigned
		if _, ok := rootMapper[protobufName]; ok {
			return nil, fmt.Errorf(DuplicateProtobufTagNameError, protobufName)
		}

		// Add the field to the map
		rootMapper[field.Name] = protobufName
	}

	return &Mapper{
		Fields:        rootMapper,
		NestedMappers: rootNestedMappers,
	}, nil
}

// NewMapper creates the fields to validate from a JSON struct
func (j *JSONGenerator) NewMapper(structInstance interface{}) (
	*Mapper,
	error,
) {
	// Reflection of data
	typeReflection := reflect.TypeOf(structInstance)

	// If data is a pointer, dereference it
	if typeReflection.Kind() == reflect.Ptr {
		typeReflection = typeReflection.Elem()
	}

	// Initialize the map fields and the map of nested mappers
	rootMapper := make(map[string]string)
	rootNestedMappers := make(map[string]*Mapper)

	// Reflection of the type of data
	var jsonTag string
	var jsonName string
	for i := 0; i < typeReflection.NumField(); i++ {
		// Get the field type through reflection
		field := typeReflection.Field(i)

		// Print field on debug mode
		fieldType := field.Type
		if j.mode != nil && j.mode.IsDebug() {
			fmt.Printf("field '%v' type: %v\n", field.Name, fieldType)
		}

		// Get the JSON tag of the field
		jsonTag = field.Tag.Get(JSONTag)
		if jsonTag == "" {
			// Check if the field is a protoc generated field
			if field.Name == State || field.Name == SizeCache || field.Name == UnknownFields {
				return nil, fmt.Errorf(
					MissingJSONTagLooksLikeProtocFieldError,
					field.Name,
				)
			}
			return nil, fmt.Errorf(MissingJSONTagError, field.Name)
		}

		// Check if the JSON tag is unassigned
		if jsonTag == "-" {
			continue
		}

		// Check the tag to determine if it contains 'omitempty', which means it is an optional field
		if ok := strings.Contains(jsonTag, JSONOmitempty); ok {
			continue
		}

		// Check if the field is a pointer
		if fieldType.Kind() == reflect.Ptr {
			fieldType = fieldType.Elem()
		}

		// Check if the element type is a struct
		if fieldType.Kind() == reflect.Struct {
			// Create a new Mapper for the nested struct field
			fieldNestedMapper, err := j.NewMapper(
				reflect.New(fieldType).Interface(),
			)
			if err != nil {
				return nil, err
			}

			// Add the nested fields to the map
			rootNestedMappers[field.Name] = fieldNestedMapper
		}

		// Get the field name from the JSON tag
		tagParts := strings.Split(jsonTag, ",")
		if len(tagParts) == 0 {
			return nil, fmt.Errorf(EmptyJSONTagError, field.Name)
		}
		jsonName = tagParts[0]

		// Check if the field name has already been assigned
		if _, ok := rootMapper[jsonName]; ok {
			return nil, fmt.Errorf(DuplicateJSONTagNameError, jsonName)
		}

		// Add the field to the map
		rootMapper[field.Name] = jsonName
	}

	return &Mapper{
		Fields:        rootMapper,
		NestedMappers: rootNestedMappers,
	}, nil
}
